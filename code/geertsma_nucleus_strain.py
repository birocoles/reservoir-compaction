"""
Forward modelling of elastic reservoir deformation produced by a set
of nucleus of strain.

The displacement components are computed by using the Geertsma's model
(Fjær et al., 2008, p. 403). The equations are valid outside the reservoir.

References
----------

Fjær, E, Holt, R., M., Horsrud, P., Raaen, A. M., and Risnes, R. (2008).
Petroleum Related Rock Mechanics. Elsevier, 2nd edition. ISBN:978-0-444-50260-5

"""

import numpy as np
from numba import njit
from compaction import Cm


def displacement_x_component(coordinates, nuclei, pressure, poisson, young):
    """
    x-component of the displacement field.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.

    Returns
    -------
    result : array
        x-component of the displacement field generated by the nuclei at the
        computation points.
    """
    d_x1  = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_x1'
    )

    d_x2  = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_x2'
    )

    d_xz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_xz2'
    )

    result = d_x1 + (3 - 4*poisson)*d_x2 + d_xz2

    return result


def displacement_y_component(coordinates, nuclei, pressure, poisson, young):
    """
    y-component of the displacement field.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.

    Returns
    -------
    result : array
        y-component of the displacement field generated by the nuclei at the
        computation points.
    """
    d_y1 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_y1'
    )

    d_y2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_y2'
    )

    d_yz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_yz2'
    )

    result = d_y1 + (3 - 4*poisson)*d_y2 + d_yz2

    return result


def displacement_z_component(coordinates, nuclei, pressure, poisson, young):
    """
    z-component of the displacement field.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.

    Returns
    -------
    result : array
        z-component of the displacement field generated by the nuclei at the
        computation points.
    """
    d_z1 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_z1'
    )

    d_z2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_z2'
    )

    d_zz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='d_zz2'
    )

    result = d_z1 - (3 - 4*poisson)*d_z2 + d_zz2

    return result


def stress_x_component(coordinates, nuclei, pressure, poisson, young):
    """
    x-component of the stress field.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.

    Returns
    -------
    result : array
        x-component of the stress field generated by the nuclei at the
        computation points.
    """

    s_xz1  = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_xz1'
    )

    s_xz2  = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_xz2'
    )

    s_xzz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_xzz2'
    )

    result = s_xz1 + s_xzz2 + s_xz2
    result *= young/(1 + poisson)

    return result


def stress_y_component(coordinates, nuclei, pressure, poisson, young):
    """
    y-component of the stress field.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.

    Returns
    -------
    result : array
        y-component of the stress field generated by the nuclei at the
        computation points.
    """

    s_yz1 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_yz1'
    )

    s_yz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_yz2'
    )

    s_yzz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_yzz2'
    )

    result = s_yz1 + s_yzz2 + s_yz2
    result *= young/(1 + poisson)

    return result


def stress_z_component(coordinates, nuclei, pressure, poisson, young):
    """
    z-component of the stress field.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.

    Returns
    -------
    result : array
        z-component of the stress field generated by the nuclei at the
        computation points.
    """

    s_zz1 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_zz1'
    )

    s_zz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_zz2'
    )

    s_zzz2 = field_component(
        coordinates, nuclei, pressure, poisson, young, kernel='s_zzz2'
    )

    result = s_zz1 + s_zzz2 - s_zz2
    result *= young/(1 + poisson)

    return result


def field_component(
    coordinates, nuclei, pressure, poisson, young, kernel, dtype="float64",
    disable_checks=False
):
    """
    Displacement and stress components produced by pore-pressure variations in
    right-rectangular nuclei.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.
    kernel : func
        Kernel function to be used for computing the desired field component.
        The available kernels for displacement components are:
        -  x-component of the 1st system: ``d_x1``
        -  y-component of the 1st system: ``d_y1``
        -  z-component of the 1st system: ``d_z1``
        -  x-component of the 2nd system: ``d_x2``
        -  y-component of the 2nd system: ``d_y2``
        -  z-component of the 2nd system: ``d_z2``
        - xz-component of the 2nd system: ``d_xz2``
        - yz-component of the 2nd system: ``d_yz2``
        - zz-component of the 2nd system: ``d_zz2``
        The available kernels for stress components are:
        -  xz-component of the 1nd system: ``s_xz1``
        -  yz-component of the 1nd system: ``s_yz1``
        -  zz-component of the 1nd system: ``s_zz1``
        - xzz-component of the 2nd system: ``s_xzz2``
        - yzz-component of the 2nd system: ``s_yzz2``
        - zzz-component of the 2nd system: ``s_zzz2``
        -  xz-component of the 2nd system: ``s_xz2``
        -  yz-component of the 2nd system: ``s_yz2``
        -  zz-component of the 2nd system: ``s_zz2``
    dtype : data-type (optional)
        Data type assigned to the resulting field component. Default to
        ``np.float64``.
    disable_checks : bool (optional)
        Flag that controls whether to perform a sanity check on the model.
        Should be set to ``True`` only when it is certain that the input model
        is valid and it does not need to be checked.
        Default to ``False``.

    Returns
    -------
    result : array
        Field component generated by the nuclei at the computation points.
    """
    kernels = {
        "d_x1": kernel_d_x1,
        "d_y1": kernel_d_y1,
        "d_z1": kernel_d_z1,
        "d_x2": kernel_d_x2,
        "d_y2": kernel_d_y2,
        "d_z2": kernel_d_z2,
        "d_xz2": kernel_d_xz2,
        "d_yz2": kernel_d_yz2,
        "d_zz2": kernel_d_zz2,
        "s_xz1": kernel_s_xz1,
        "s_yz1": kernel_s_yz1,
        "s_zz1": kernel_s_zz1,
        "s_xz2": kernel_s_xz2,
        "s_yz2": kernel_s_yz2,
        "s_zz2": kernel_s_zz2,
        "s_xzz2": kernel_s_xzz2,
        "s_yzz2": kernel_s_yzz2,
        "s_zzz2": kernel_s_zzz2
    }
    if kernel not in kernels:
        raise ValueError("Kernel {} not recognized".format(kernel))
    # Figure out the shape and size of the output array
    cast = np.broadcast(*coordinates[:3])
    result = np.zeros(cast.size, dtype=dtype)
    # Convert coordinates, nuclei and pressure to arrays with proper shape
    coordinates = tuple(np.atleast_1d(i).ravel() for i in coordinates[:3])
    nuclei = np.atleast_2d(nuclei)
    assert np.isscalar(pressure), 'pressure must be a scalar'

    # Compute the component
    jit_field_component(
        coordinates, nuclei, pressure, kernels[kernel], result
    )
    result *= -Cm(poisson, young)/(4*np.pi)
    return result.reshape(cast.shape)



@njit
def jit_field_component(
    coordinates, nuclei, pressure, kernel, out
):
    """
    Compute the displacement or stress component at the computations points

    Parameters
    ----------
    coordinates : 1d array
        1d array containing ``y``, ``x`` and ``z`` Cartesian coordinates of the
        computation points (in meters).
    nuclei : 2d-array
        2d array containing the Cartesian coordinates of the nuclei. Each
        line contains the coordinates of a nucleus in following order: y, x,
        and z. All coordinates should be in meters.
    pressure : scalar
        Pressure variation of all nuclei in MPa.
    kernel : func
        Kernel function to be used for computing the desired field component.
    out : 1d-array
        Array where the resulting field component values will be stored.
        Must have the same size as the arrays contained on ``coordinates``.
    """
    # Iterate over computation points and nuclei
    for l in range(coordinates[0].size):
        for nucleus in nuclei:
            # Iterate over the nuclei
            out[l] += (
                pressure
                * kernel(
                    nucleus[0],
                    nucleus[1],
                    nucleus[2],
                    coordinates[0][l],
                    coordinates[1][l],
                    coordinates[2][l]
                )
            )

@njit
def kernel_d_x1(y, x, z, yp, xp, zp):
    """
    Kernel for x-component of displacement in the infinite space domain
    (1st system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = X/rho**3
    return kernel


@njit
def kernel_d_y1(y, x, z, yp, xp, zp):
    """
    Kernel for y-component of displacement in the infinite space domain
    (1st system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Y/rho**3
    return kernel


@njit
def kernel_d_z1(y, x, z, yp, xp, zp):
    """
    Kernel for z-component of displacement in the infinite space domain
    (1st system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Z/rho**3
    return kernel


@njit
def kernel_d_x2(y, x, z, yp, xp, zp):
    """
    Kernel for x-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z + zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = X/rho**3
    return kernel


@njit
def kernel_d_y2(y, x, z, yp, xp, zp):
    """
    Kernel for y-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z + zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Y/rho**3
    return kernel


@njit
def kernel_d_z2(y, x, z, yp, xp, zp):
    """
    Kernel for z-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z + zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Z/rho**3
    return kernel


@njit
def kernel_d_xz2(y, x, z, yp, xp, zp):
    """
    Kernel for xz-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z + zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = 2 * zp *((3*X*Z)/rho**5)
    return kernel


@njit
def kernel_d_yz2(y, x, z, yp, xp, zp):
    """
    Kernel for yz-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z + zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = 2 * zp * ((3*Y*Z)/rho**5)
    return kernel


@njit
def kernel_d_zz2(y, x, z, yp, xp, zp):
    """
    Kernel for zz-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z + zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel =  2 * zp * ( (3*(Z**2))/rho**5  - ( 1./rho**3 ) )
    return kernel


def nuclei_layer_rectangular(region, shape, z0):
    '''
    Create a rectangular planar layer of nuclei.
    '''
    y1, y2, x1, x2 = region
    assert y2 > y1, 'y2 must be greater than y1'
    assert x2 > x1, 'x2 must be greater than x1'
    assert bottom > top, 'bottom must be greater than top (z points downward)'
    dy = (y2 - y1)/shape[0]
    dx = (x2 - x1)/shape[1]
    half_dy = 0.5*dy
    half_dx = 0.5*dx
    layer = []
    y = y1
    for i in range(shape[0]):
        x = x1
        for j in range(shape[1]):
            layer.append([y + half_dy, x + half_dx, z0])
            x += dx
        y += dy
    layer = np.array(layer)
    return layer


def nuclei_layer_circular(center, radius, shape, z0):
    '''
    Create a circular planar layer of nuclei.
    '''
    y0, x0 = center
    assert radius > 0, 'radius must be positive'
    y_min = y0 - radius
    y_max = y0 + radius
    x_min = x0 - radius
    x_max = x0 + radius
    dy = (y_max - y_min)/shape[0]
    dx = (x_max - x_min)/shape[1]
    half_dy = 0.5*dy
    half_dx = 0.5*dx
    layer = []
    y = y_min
    for i in range(shape[0]):
        x = x_min
        for j in range(shape[1]):
            r_prism = np.sqrt((x + half_dx)**2 + (y + half_dy)**2)
            if r_prism <= radius:
                layer.append([y + half_dy, x + half_dx, z0])
            x += dx
        y += dy
    layer = np.array(layer)
    return layer
