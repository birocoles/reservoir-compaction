"""
Forward modelling of displacement produced by pressure variations in prisms
"""
import numpy as np
from numba import jit


def displacement(
    coordinates, prisms, pressure, poisson, young, field, dtype="float64",
    disable_checks=False
):
    """
    Displacement components produced by pressure variation in right-rectangular
    prisms

    The displacement components are computed by using the expressions
    presented by Muñoz and Roehl (2017) and also by using alternative
    expressions adapted from Nagy et al. (2000) and Nagy et al. (2002).
    The present code is heavily based on Harmonica (Uieda et al., 2020) and
    uses expressions which are valid at any point, either outside or inside the
    prism.

    By following Uieda et al. (2020), the expressions based on
    Nagy et al. (2000) and Nagy et al. (2002) makes use of the modified
    arctangent function proposed by Fukushima (2019) so that the
    solution to satisfies Poisson's equation in the entire domain. Moreover,
    the logarithm function was also modified in order to solve the
    singularities that the analytical solution has on some points.

    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    prisms : 2d-array
        2d array containing the Cartesian coordinates of the prism(s). Each
        line contains the coordinates of a prism in following order: y1, y2,
        x1, x2, z2 and z1. All coordinates should be in meters.
    pressure : 1d array
        1d array containing the pressure of each prism in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.
    field : str
        Displacement component to be computed. The available components are:

        Expressions based on Nagy et al. (2000) and Nagy et al. (2002)
        - x-component of the 1st system: ``u_x1_NA``
        - y-component of the 1st system: ``u_y1_NA``
        - z-component of the 1st system: ``u_z1_NA``
        - x-component of the 2nd system: ``u_x2_NA``
        - y-component of the 2nd system: ``u_y2_NA``
        - z-component of the 2nd system: ``u_z2_NA``
        - xz-component of the 2nd system: ``u_xz2_NA``
        - yz-component of the 2nd system: ``u_yz2_NA``
        - zz-component of the 2nd system: ``u_zz2_NA``

        Expressions based on Muñoz and Roehl (2017)
        - x-component of the 1st system given: ``u_x1_MR``
        - x-component of the 2nd system given: ``u_x2_MR``
        - xz-component of the 2nd system given: ``u_xz2_MR``

    dtype : data-type (optional)
        Data type assigned to the resulting displacement component. Default to
        ``np.float64``.
    disable_checks : bool (optional)
        Flag that controls whether to perform a sanity check on the model.
        Should be set to ``True`` only when it is certain that the input model
        is valid and it does not need to be checked.
        Default to ``False``.

    Returns
    -------
    result : array
        Displacement component generated by the prisms on the computation points.

    References
    ----------

    Nagy, D., Papp, G. and Benedek, J.(2000). The gravitational potential and
    its derivatives for the prism. Journal of Geodesy 74: 552.
    doi:10.1007/s001900000116

    Nagy, D., Papp, G. and Benedek, J.(2002). Corrections to “The gravitational
    potential and its derivatives for the prism”. Journal of Geodesy 76: 475.
    doi:10.1007/s00190-002-0264-7

    Muñoz, L. F. P. and Roehl, D. (2017). An analytical solution for
    displacements due to reservoir compaction under arbitrary pressure changes.
    Applied Mathematical Modelling 52: 145. doi:10.1016/j.apm.2017.06.023

    Fukushima, T. (2019). Fast computation of prismatic gravitational field.
    doi:10.13140/RG.2.2.30598.93766

    Uieda, Leonardo, Soler, Santiago R., Pesce, Agustina, Oliveira Jr,
    Vanderlei C, and Shea, Nicholas. (2020, February 27). Harmonica: Forward
    modeling, inversion, and processing gravity and magnetic data
    (Version v0.1.0). Zenodo. doi:10.5281/zenodo.3628742

    """
    kernels = {
        "u_x1_NA": kernel_u_x1_NA,
        "u_x2_NA": kernel_u_x2_NA,
        "u_xz2_NA": kernel_u_xz2_NA,
        "u_y1_NA": kernel_u_y1_NA,
        "u_y2_NA": kernel_u_y2_NA,
        "u_yz2_NA": kernel_u_yz2_NA,
        "u_z1_NA": kernel_u_z1_NA,
        "u_z2_NA": kernel_u_z2_NA,
        "u_zz2_NA": kernel_u_zz2_NA,
        "u_x1_MR": kernel_u_x1_MR,
        "u_x2_MR": kernel_u_x2_MR,
        "u_xz2_MR": kernel_u_xz2_MR,
        "u_y1_MR": kernel_u_y1_MR,
        "u_y2_MR": kernel_u_y2_MR,
        "u_yz2_MR": kernel_u_yz2_MR,
        "u_z1_MR": kernel_u_z1_MR,
        "u_z2_MR": kernel_u_z2_MR,
        "u_zz2_MR": kernel_u_zz2_MR
    }
    if field not in kernels:
        raise ValueError("Displacement {} not recognized".format(field))
    # Figure out the shape and size of the output array
    cast = np.broadcast(*coordinates[:3])
    result = np.zeros(cast.size, dtype=dtype)
    # Convert coordinates, prisms and pressure to arrays with proper shape
    coordinates = tuple(np.atleast_1d(i).ravel() for i in coordinates[:3])
    prisms = np.atleast_2d(prisms)
    pressure = np.atleast_1d(pressure).ravel()
    # Sanity checks
    if not disable_checks:
        if pressure.size != prisms.shape[0]:
            raise ValueError(
                "Number of elements in pressure ({}) ".format(pressure.size)
                + "mismatch the number of prisms ({})".format(prisms.shape[0])
            )
        _check_prisms(prisms)
    # Compute displacement field
    jit_displacement(
        coordinates, prisms, pressure, poisson, kernels[field], result
    )
    result *= -Cm(poisson, young)/(4*np.pi)
    return result.reshape(cast.shape)


def _check_prisms(prisms):
    """
    Check if prisms boundaries are well defined

    Parameters
    ----------
    prisms : 2d-array
        Array containing the boundaries of the prisms in the following order:
        ``y1``, ``y2``, ``x1``, ``x2``, ``z2``, ``z1``.
        The array must have the following shape: (``n_prisms``, 6), where
        ``n_prisms`` is the total number of prisms.
        This array of prisms must have valid boundaries.
        Run ``_check_prisms`` before.
    """
    y1, y2, x1, x2, z2, z1 = tuple(prisms[:, i] for i in range(6))
    err_msg = "Invalid prism or prisms. "
    bad_y = y1 > y2
    bad_x = x1 > x2
    bad_z = z1 > z2
    if bad_y.any():
        err_msg += "The y1 boundary can't be greater than the y2 one.\n"
        for prism in prisms[bad_y]:
            err_msg += "\tInvalid prism: {}\n".format(prism)
        raise ValueError(err_msg)
    if bad_x.any():
        err_msg += "The x1 boundary can't be greater than the x2 one.\n"
        for prism in prisms[bad_x]:
            err_msg += "\tInvalid prism: {}\n".format(prism)
        raise ValueError(err_msg)
    if bad_z.any():
        err_msg += "The z2 radius boundary can't be greater than the z1 one.\n"
        for prism in prisms[bad_z]:
            err_msg += "\tInvalid prism: {}\n".format(prism)
        raise ValueError(err_msg)


@jit(nopython=True)
def jit_displacement(
    coordinates, prisms, pressure, poisson, kernel, out
):  # pylint: disable=invalid-name
    """
    Compute displacement component at the computations points

    Parameters
    ----------
    coordinates : 1d array
        1d array containing ``y``, ``x`` and ``z`` Cartesian coordinates of the
        computation points (in meters).
    prisms : 2d-array
        2d array containing the Cartesian coordinates of the prism(s). Each
        line contains the coordinates of a prism in following order: y1, y2,
        x1, x2, z2 and z1. All coordinates should be in meters.
    pressure : 1d array
        1d array containing the pressure of each prism in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.
    kernel : func
        Kernel function that will be used to compute the desired component.
    out : 1d-array
        Array where the resulting field values will be stored.
        Must have the same size as the arrays contained on ``coordinates``.
    """
    # Iterate over computation points and prisms
    for l in range(coordinates[0].size):
        for m in range(prisms.shape[0]):
            # Iterate over the prism boundaries to compute the result of the
            # integration (see Nagy et al., 2000)
            c_z = 0.5 * (prisms[m, 4] + prisms[m, 5])
            for i in range(2):
                for j in range(2):
                    for k in range(2):
                        y_prism = prisms[m, 1 - i]
                        x_prism = prisms[m, 3 - j]
                        z_prism = prisms[m, 5 - k]
                        # If i, j or k is 1, the shift_* will refer to the
                        # lower boundary, meaning the corresponding term should
                        # have a minus sign
                        out[l] += (
                            pressure[m]
                            * (-1) ** (i + j + k)
                            * kernel(
                                y_prism,
                                x_prism,
                                z_prism,
                                c_z,
                                coordinates[0][l],
                                coordinates[1][l],
                                coordinates[2][l]
                            )
                        )


@jit(nopython=True)
def kernel_u_x1_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for x-component of the infinite space condition (first system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        Y * safe_log(Z + rho)
        + Z * safe_log(Y + rho)
        - X * safe_atan2(Y * Z, X * rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_y1_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for y-component of the infinite space condition (first system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        X * safe_log(Z + rho)
        + Z * safe_log(X + rho)
        - Y * safe_atan2(X * Z, Y * rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_z1_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for z-component of the infinite space condition (first system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        X * safe_log(Y + rho)
        + Y * safe_log(X + rho)
        - Z * safe_atan2(X * Y, Z * rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_x2_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for x-component of the semi-space condition (second system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        Y * safe_log(Z + rho)
        + Z * safe_log(Y + rho)
        - X * safe_atan2(Y * Z, X * rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_y2_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for y-component of the semi-space condition (second system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        X * safe_log(Z + rho)
        + Z * safe_log(X + rho)
        - Y * safe_atan2(X * Z, Y * rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_z2_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for z-component of the semi-space condition (second system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        X * safe_log(Y + rho)
        + Y * safe_log(X + rho)
        - Z * safe_atan2(X * Y, Z * rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_xz2_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for xz-component of the semi-space condition (second system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = 2 * zp * (
        safe_log(Y + rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_yz2_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for yz-component of the semi-space condition (second system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = 2 * zp * (
        safe_log(X + rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_zz2_NA(y, x, z, cz, yp, xp, zp):
    """
    Kernel for zz-component of the semi-space condition (second system)
    computed with expressions given by Nagy et al. (2000)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = 2 * zp * (
        - safe_atan2(X * Y, Z * rho)
    )
    return kernel


@jit(nopython=True)
def kernel_u_x1_MR(y, x, z, cz , yp, xp, zp):
    """
    Kernel for x-component of the infinite space condition (first system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    epsilon = np.sign(zp - cz)
    kernel = epsilon * (
        Y * safe_log(Z + rho)
        + Z * safe_log(Y + rho)
        - 0.5 * X * 1j * safe_log(X ** 2 + Y ** 2 + X * Z * 1j + Y * rho)
        + 0.5 * X * 1j * safe_log(X ** 2 + Y ** 2 - X * Z * 1j + Y * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_x2_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for x-component of the semi-space condition (second system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z + 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        Y * safe_log(Z + rho)
        + Z * safe_log(Y + rho)
        - 0.5 * X * 1j * safe_log(X ** 2 + Y ** 2 + X * Z * 1j + Y * rho)
        + 0.5 * X * 1j * safe_log(X ** 2 + Y ** 2 - X * Z * 1j + Y * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_xz2_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for xz-component of the semi-space condition (second system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z + 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = - (1/3) * zp * (
        safe_log(X ** 2 + Y ** 2 - X * Z * 1j + Y * rho)
        + safe_log(X ** 2 + Y ** 2 + X * Z * 1j + Y * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_y1_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for y-component of the infinite space condition (first system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    epsilon = np.sign(zp - cz)
    kernel = epsilon * (
        X * safe_log(Z + rho)
        + Z * safe_log(X + rho)
        - 0.5 * Y * 1j * safe_log(X ** 2 + Y ** 2 + Y * Z * 1j + X * rho)
        + 0.5 * Y * 1j * safe_log(X ** 2 + Y ** 2 - Y * Z * 1j + X * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_y2_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for y-component of the semi-space condition (second system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z + 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        X * safe_log(Z + rho)
        + Z * safe_log(X + rho)
        - 0.5 * Y * 1j * safe_log(X ** 2 + Y ** 2 + Y * Z * 1j + X * rho)
        + 0.5 * Y * 1j * safe_log(X ** 2 + Y ** 2 - Y * Z * 1j + X * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_yz2_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for yz-component of the semi-space condition (second system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z + 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = - (1/3) * zp * (
        safe_log(X ** 2 + Y ** 2 - Y * Z * 1j + X * rho)
        + safe_log(X ** 2 + Y ** 2 + Y * Z * 1j + X * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_z1_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for z-component of the infinite space condition (first system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    epsilon = np.sign(zp - cz)
    kernel = epsilon * (
        X * safe_log(Y + rho)
        + Y * safe_log(X + rho)
        + 0.5 * Z * 1j * safe_log(Y ** 2 + Z ** 2 + X * Z * 1j + Y * rho)
        - 0.5 * Z * 1j * safe_log(- Y ** 2 - Z ** 2 + X * Z * 1j - Y * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_z2_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for z-component of the semi-space condition (second system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z + 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (
        X * safe_log(Y + rho)
        + Y * safe_log(X + rho)
        + 0.5 * Z * 1j * safe_log(Y ** 2 + Z ** 2 + X * Z * 1j + Y * rho)
        - 0.5 * Z * 1j * safe_log(- Y ** 2 - Z ** 2 + X * Z * 1j - Y * rho)
    ).real
    return kernel


@jit(nopython=True)
def kernel_u_zz2_MR(y, x, z, cz, yp, xp, zp):
    """
    Kernel for zz-component of the semi-space condition (second system)
    computed with expressions given by Muñoz and Roehl (2017)
    """
    Y = yp - y
    X = xp - x
    Z = zp - z + 2 * cz
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = (1/3) * zp * 1j * (
        safe_log(- X ** 2 - Z ** 2 + Y * Z * 1j + X * rho)
        - safe_log(X ** 2 + Z ** 2 + Y * Z * 1j + X * rho)
    )
    return kernel.real


@jit(nopython=True)
def safe_atan2(numerator, denominator):
    """
    Principal value of the arctangent expressed as a two variable function

    This modification has to be made to the arctangent function so the
    gravitational field of the prism satisfies the Poisson's equation.
    Therefore, it guarantees that the fields satisfies the symmetry properties
    of the prism. This modified function has been defined according to
    Fukushima (2019).
    """
    if denominator != 0:
        result = np.arctan(numerator / denominator)
    else:
        if numerator > 0:
            result = np.pi / 2
        elif numerator < 0:
            result = -np.pi / 2
        else:
            result = 0
    return result


@jit(nopython=True)
def safe_log(argument):
    """
    Modified log to return 0 for log(0).
    The limits in the formula terms tend to 0 (see Nagy et al., 2000).
    """
    if np.abs(argument) < 1e-10:
        result = 0
    else:
        result = np.log(argument)
    return result


@jit(nopython=True)
def Cm(poisson, young):
    """
    Uniaxial compaction coefficient Cm (Tempone et al, 2010).
    """
    result = ((1+poisson)*(1-2*poisson))/(young*(1-poisson))
    return result


def prism_layer_rectangular(region, shape, bottom, top):
    '''
    Create a rectangular planar layer of prisms.
    '''
    y1, y2, x1, x2 = region
    assert y2 > y1, 'y2 must be greater than y1'
    assert x2 > x1, 'x2 must be greater than x1'
    assert bottom > top, 'bottom must be greater than top (z points downward)'
    dy = (y2 - y1)/shape[0]
    dx = (x2 - x1)/shape[1]
    layer = []
    y = y1
    for i in range(shape[0]):
        x = x1
        for j in range(shape[1]):
            layer.append([y, y+dy, x, x+dx, bottom, top])
            x += dx
        y += dy
    layer = np.array(layer)
    return layer


def prism_layer_circular(center, radius, shape, bottom, top):
    '''
    Create a circular planar layer of prisms.
    '''
    y0, x0 = center
    assert radius > 0, 'radius must be positive'
    assert bottom > top, 'bottom must be greater than top (z points downward)'
    y_min = y0 - radius
    y_max = y0 + radius
    x_min = x0 - radius
    x_max = x0 + radius
    dy = (y_max - y_min)/shape[0]
    dx = (x_max - x_min)/shape[1]
    half_dy = 0.5*dy
    half_dx = 0.5*dx
    layer = []
    y = y_min
    for i in range(shape[0]):
        yc = y + half_dy - y0
        x = x_min
        for j in range(shape[1]):
            xc = x + half_dx - x0
            r_prism = np.sqrt(xc**2 + yc**2)
            if r_prism <= radius:
                layer.append([y, y+dy, x, x+dx, bottom, top])
            x += dx
        y += dy
    layer = np.array(layer)
    return layer
