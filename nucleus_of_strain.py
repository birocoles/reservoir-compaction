#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Sep  3 08:40:44 2020

@author: valcris

Forward modelling Geertsma’s nucleus of strain model

"""
import numpy as np
from numba import njit


def d_field_x_component_ns(coordinates, model, DP, poisson, young):
    """
    x-component of the displacement of Geertsma’s nucleus of strain model
    """
    d_x1  = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_x1')
    d_x2  = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_x2')
    d_xz2 = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_xz2')
    
    return d_x1, d_x2, d_xz2

def d_field_y_component_ns(coordinates, model, DP, poisson, young):
    """
    y-component of the displacement of Geertsma’s nucleus of strain model
    """
    d_y1 = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_y1')

    d_y2 = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_y2')

    d_yz2 = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_yz2')
    
    return d_y1, d_y2, d_yz2

def d_field_z_component_ns(coordinates, model, DP, poisson, young):
    """
    z-component of the displacement Geertsma’s nucleus of strain model
    """
    d_z1 = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_z1')

    d_z2 = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_z2')

    d_zz2 = field_component_ns(coordinates, model, DP, poisson, young, kernel='d_zz2')
    
    return d_z1, d_z2, d_zz2


def field_component_ns(
    coordinates, prisms, pressure, poisson, young, kernel, dtype="float64",
    disable_checks=False
):
    """
    Displacement components produced by Geertsma’s nucleus of strain model

    The displacement components are computed by Geertsma’s nucleus of strain model

    
    Parameters
    ----------
    coordinates : 2d-array
        2d numpy array containing ``y``, ``x`` and ``z`` Cartesian cordinates
        of the computation points. All coordinates should be in meters.
    prisms : 2d-array
        2d array containing the Cartesian coordinates of the nucleus of strain. 
        Each line contains the coordinates of a nucleus of strain in following order:
        y1, x1, and z1. All coordinates should be in meters.
    pressure : 1d array
        1d array containing the pressure of each prism in MPa.
    poisson : float
        Poisson’s ratio.
    young : float
        Young’s modulus in MPa.
    kernel : func
        Kernel function to be used for computing the desired field component.
        The available kernels for displacement components are:
        -  x-component of the 1st system: ``d_x1``
        -  y-component of the 1st system: ``d_y1``
        -  z-component of the 1st system: ``d_z1``
        -  x-component of the 2nd system: ``d_x2``
        -  y-component of the 2nd system: ``d_y2``
        -  z-component of the 2nd system: ``d_z2``
        - xz-component of the 2nd system: ``d_xz2``
        - yz-component of the 2nd system: ``d_yz2``
        - zz-component of the 2nd system: ``d_zz2``      
    dtype : data-type (optional)
        Data type assigned to the resulting field component. Default to
        ``np.float64``.
    disable_checks : bool (optional)
        Flag that controls whether to perform a sanity check on the model.
        Should be set to ``True`` only when it is certain that the input model
        is valid and it does not need to be checked.
        Default to ``False``.

    Returns
    -------
    result : array
        Field component generated by the prisms at the computation points.

    References
    ----------

    """
    
    kernels = {
        "d_x1": kernel_d_x1,
        "d_y1": kernel_d_y1,
        "d_z1": kernel_d_z1,
        "d_x2": kernel_d_x2,
        "d_y2": kernel_d_y2,
        "d_z2": kernel_d_z2,
        "d_xz2": kernel_d_xz2,
        "d_yz2": kernel_d_yz2,
        "d_zz2": kernel_d_zz2,
    }
    if kernel not in kernels:
        raise ValueError("Kernel {} not recognized".format(kernel))
    # Figure out the shape and size of the output array
    cast = np.broadcast(*coordinates[:3])
    result = np.zeros(cast.size, dtype=dtype)
    # Convert coordinates, prisms and pressure to arrays with proper shape
    coordinates = tuple(np.atleast_1d(i).ravel() for i in coordinates[:3])
    prisms = np.atleast_2d(prisms)
    pressure = np.atleast_1d(pressure).ravel()
    # Sanity checks
    if not disable_checks:
        if pressure.size != prisms.shape[0]:
            raise ValueError(
                "Number of elements in pressure ({}) ".format(pressure.size)
                + "mismatch the number of prisms ({})".format(prisms.shape[0])
            )
        #_check_prisms(prisms)
    # Compute the component
    jit_field_component_ns(
        coordinates, prisms, pressure, kernels[kernel], result
    )
    result *= -Cm(poisson, young)/(4*np.pi)
    return result.reshape(cast.shape)



@njit
def jit_field_component_ns(
    coordinates, prisms, pressure, kernel, out
):
    """
    Compute the displacement component at the computations points

    Parameters
    ----------
    coordinates : 1d array
        1d array containing ``y``, ``x`` and ``z`` Cartesian coordinates of the
        computation points (in meters).
    prisms : 2d-array
        2d array containing the Cartesian coordinates of the nucleus of strain. Each
        line contains the coordinates of a nucleus of strain in following order: 
        y1,x1, and z1. All coordinates should be in meters.
    pressure : 1d array
        1d array containing the pressure of each prism in MPa.
    kernel : func
        Kernel function to be used for computing the desired field component.
    out : 1d-array
        Array where the resulting field component values will be stored.
        Must have the same size as the arrays contained on ``coordinates``.
    """
    # Iterate over computation points and prisms
    for l in range(coordinates[0].size):
        for m in range(prisms.shape[0]):
            # 
            c_z = prisms[m, 2] 
            y_prism = prisms[m, 0]
            x_prism = prisms[m, 1]
            z_prism = prisms[m, 2]
            out[l] += (pressure[m]
                   * kernel(y_prism,x_prism,z_prism,c_z,
                                coordinates[0][l],
                                coordinates[1][l],
                                coordinates[2][l]
                            )
                        )



@njit
def kernel_d_x1(y, x, z, zc, yp, xp, zp):
    """
    Kernel for x-component of displacement in the infinite space domain
    (1st system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = X/(rho)**3
    return kernel
    

@njit
def kernel_d_y1(y, x, z, zc, yp, xp, zp):
    """
    Kernel for y-component of displacement in the infinite space domain
    (1st system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Y/(rho)**3
    return kernel
    
@njit
def kernel_d_z1(y, x, z, zc, yp, xp, zp):
    """
    Kernel for z-component of displacement in the infinite space domain
    (1st system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Z/(rho)**3
    return kernel
        

@njit
def kernel_d_x2(y, x, z, zc, yp, xp, zp):
    """
    Kernel for x-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * zc
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = X/(rho)**3
    return kernel
    

@njit
def kernel_d_y2(y, x, z, zc, yp, xp, zp):
    """
    Kernel for y-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * zc
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Y/(rho)**3
    return kernel
    
@njit
def kernel_d_z2(y, x, z, zc, yp, xp, zp):
    """
    Kernel for z-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * zc
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = Z/(rho)**3
    return kernel
        


@njit
def kernel_d_xz2(y, x, z, zc, yp, xp, zp):
    """
    Kernel for xz-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * zc
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = 2 * zp *((3*X*Z)/(rho)**5)
    return kernel

@njit
def kernel_d_yz2(y, x, z, zc, yp, xp, zp):
    """
    Kernel for yz-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * zc
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel = 2 * zp * ((3*Y*Z)/(rho)**5)
    return kernel



@njit
def kernel_d_zz2(y, x, z, zc, yp, xp, zp):
    """
    Kernel for z-component of displacement in the semi-infinite space domain
    (2nd system)
    """
    Y = y - yp
    X = x - xp
    Z = z - zp - 2 * zc
    rho = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    kernel =  2 * zp * ( (3*(Z**2))/(rho)**5  - ( 1./(rho)**3 ) )
    return kernel

   
    
    
def nucleus_layer_circular(center, radius, shape, bottom, top):
    '''
    Create a circular planar layer of nucleus of strain model
    '''
    y0, x0 = center
    assert radius > 0, 'radius must be positive'
    assert bottom > top, 'bottom must be greater than top (z points downward)'
    y_min = y0 - radius
    y_max = y0 + radius
    x_min = x0 - radius
    x_max = x0 + radius
    dy = (y_max - y_min)/shape[0]
    dx = (x_max - x_min)/shape[1]
    half_dy = 0.5*dy
    half_dx = 0.5*dx
    layer = []
    y = y_min
    for i in range(shape[0]):
        yc = y + half_dy - y0
        x = x_min
        for j in range(shape[1]):
            xc = x + half_dx - x0
            r_prism = np.sqrt(xc**2 + yc**2)
            if r_prism <= radius:
                yn= 0.5*(y+(y+dy))
                xn= 0.5*(x+(x+dx))
                layer.append([yn, xn, 0.5*(bottom+top)])
            x += dx
        y += dy
    layer = np.array(layer)
    return layer        


@njit
def Cm(poisson, young):
    """
    Uniaxial compaction coefficient Cm (Tempone et al, 2010).
    """
    result = ((1+poisson)*(1-2*poisson))/(young*(1-poisson))
    return result
